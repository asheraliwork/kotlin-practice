import java.lang.Integer.parseInt

//Kotlin compiler creates a byte code and that byte code can run on the JVM, which is exactly equal to the byte code generated by the Java .class file. Whenever two byte coded file runs on the JVM, they can communicate with each other and this is how an interoperable feature is established in Kotlin for Java.
fun main() {
    var num: Int = 3
    var str: String = "123"
    var bln: Boolean = true
    var dbl: Double = 10.23
    val lng: Long = 123235345
    // var can be reassigned, val is assigned once

    var x = 5 //  `Int` type is inferred

    // printProduct()
    //println( " string is $x")
}

fun sum(a: Int, b: Int): Int {
    return a + b
}

//A function body can be an expression. Its return type is inferred.
fun sum2(a: Int, b: Int) = a + b

// default value 3
fun noReturn(a: Int = 3, b: Int): Unit {
    println(a + b);
}

fun noReturnOmitted(a: Int, b: Int) {
    println(a + b);
}

fun classWithProperties() {
    var rectangle = Rectangle(2.9, 3.4)

}

// extension function on Int to check if its even
    fun Int.isEven() : Boolean{
        return this % 2 == 0
    }
    fun checkEven(x: Int) : Boolean {
        return x.isEven()
    }
/////////////////////////////////////

fun whenMethod(obj: Any): String {
    var list = listOf("apple", "banana")
    when (obj) {
        1 -> "one"
        "Hello" -> "greeting"
        is Long -> "long"
        !is String -> "not string"
        in list -> "fruit"
        else -> "unknown"
    }
    return ""
}


fun whenMethod3() {
    var list = listOf("apple", "banana", "avocado")

    // mutable list can have new elements
    var mutList = mutableListOf("apple", "banana", "avocado")
    mutList.add("orange")
    //first filter,then sort, then map. then for each.
    list.filter { it.startsWith("a") }
        .sortedBy { it }
        .map { it.toUpperCase() }
        .forEach { println(it) }
}


fun rangeMethod() {
    val x = 5
    val y = 9

    if (x in 1..y + 1) {
        print("in range")
    }

}
// if (x !in 1..y+1)  used for not in range


fun printProduct() {
    var arg1: String = "3"
    var arg2: String = "7"
    val x = parseInt(arg1)
    val y = parseInt(arg2)

    print(x * y)

}

fun typeCheck(obj: Any): String? {
    return when (obj) {
        is String -> {
            obj.capitalize()
        }
        !is Long -> {
            obj.toString()
        }
        else -> {
            null
        }
    }
}

fun someMethod2() {
    val a: Int = 1 // A boxed Int (java.lang.Integer)
    val b: Long? = a.toLong() // implicit conversion yields a boxed Long (java.lang.Long)

    //smaller types are NOT implicitly converted to bigger types. This means that assigning a value of type Int to an long variable requires an explicit conversion.
}

//Boolean has a nullable counterpart Boolean? that also has the null value.